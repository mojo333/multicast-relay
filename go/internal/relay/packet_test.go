package relay

import (
	"bytes"
	"encoding/binary"
	"net"
	"net/netip"
	"testing"
)

func TestNetChecksumIPv4(t *testing.T) {
	tests := []struct {
		name     string
		header   []byte
		expected uint16
	}{
		{
			name: "IGMPv2 multicast to 224.0.0.1",
			header: []byte{
				0x46, 0xc0, 0x00, 0x20, 0xe2, 0x92, 0x00, 0x00,
				0x01, 0x02, 0x9f, 0xda, 0xc0, 0xa8, 0x01, 0x01,
				0xe0, 0x00, 0x00, 0x01, 0x94, 0x04, 0x00, 0x00,
			},
			expected: 0x9fda,
		},
		{
			name: "unicast tcp 216.58.198.174 -> 192.168.1.196",
			header: []byte{
				0x45, 0x00, 0x00, 0x34, 0xe0, 0xb3, 0x00, 0x00,
				0x79, 0x06, 0xff, 0xba, 0xd8, 0x3a, 0xc6, 0xae,
				0xc0, 0xa8, 0x01, 0xc4,
			},
			expected: 0xffba,
		},
		{
			name: "UDP DNS response",
			header: []byte{
				0x45, 0x00, 0x00, 0xb4, 0xf6, 0x22, 0x40, 0x00,
				0x40, 0x11, 0xc0, 0x00, 0xc0, 0xa8, 0x01, 0x01,
				0xc0, 0xa8, 0x01, 0xc4,
			},
			expected: 0xc000,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Zero out checksum and verify we compute the expected value
			zeroed := make([]byte, len(tt.header))
			copy(zeroed, tt.header)
			zeroed[10] = 0
			zeroed[11] = 0
			got := NetChecksum(zeroed)
			if got != tt.expected {
				t.Errorf("NetChecksum (zeroed) = 0x%04x, want 0x%04x", got, tt.expected)
			}

			// With the correct checksum in place, result should be 0
			got = NetChecksum(tt.header)
			if got != 0 {
				t.Errorf("NetChecksum (intact) = 0x%04x, want 0x0000", got)
			}
		})
	}
}

func TestNetChecksumUDP(t *testing.T) {
	tests := []struct {
		name     string
		data     []byte
		expected uint16
	}{
		{
			name: "NTP v4 client",
			data: []byte{
				// pseudo header: src_ip, dst_ip, 0, protocol, udp_length
				0xc0, 0xa8, 0x01, 0xc4, 0x5b, 0xbd, 0x5b, 0x9d,
				0x00, 0x11, 0x00, 0x38,
				// udp header + data
				0xd7, 0x6e, 0x00, 0x7b, 0x00, 0x38, 0x10, 0x1f,
				0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0xe0, 0x01, 0x7b, 0x46, 0x34, 0x2f, 0xeb, 0x36,
			},
			expected: 0x101f,
		},
		{
			name: "NTP v4 server",
			data: []byte{
				0x5b, 0xbd, 0x5b, 0x9d, 0xc0, 0xa8, 0x01, 0xc4,
				0x00, 0x11, 0x00, 0x38,
				0x00, 0x7b, 0xd5, 0x1e, 0x00, 0x38, 0x0d, 0x66,
				0x24, 0x02, 0x03, 0xe8, 0x00, 0x00, 0x08, 0x29,
				0x00, 0x00, 0x09, 0xab, 0x84, 0xf6, 0x0b, 0xe7,
				0xe0, 0x01, 0x76, 0xa5, 0x62, 0xb6, 0x0f, 0x58,
				0xe0, 0x01, 0x7c, 0x07, 0x16, 0x61, 0x28, 0xc4,
				0xe0, 0x01, 0x7c, 0x07, 0x53, 0xd6, 0x52, 0x7d,
				0xe0, 0x01, 0x7c, 0x07, 0x53, 0xda, 0xc1, 0xf6,
			},
			expected: 0x0d66,
		},
		{
			name: "DNS standard query",
			data: []byte{
				0xc0, 0xa8, 0x01, 0xc4, 0xc0, 0xa8, 0x01, 0x01,
				0x00, 0x11, 0x00, 0x4e,
				0xad, 0xa5, 0x00, 0x35, 0x00, 0x4e, 0x87, 0x4e,
				0xae, 0x06, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x01, 0x0d, 0x6e, 0x31, 0x2d,
				0x32, 0x31, 0x31, 0x36, 0x39, 0x37, 0x33, 0x36,
				0x34, 0x35, 0x09, 0x65, 0x75, 0x2d, 0x77, 0x65,
				0x73, 0x74, 0x2d, 0x31, 0x03, 0x65, 0x6c, 0x62,
				0x09, 0x61, 0x6d, 0x61, 0x7a, 0x6f, 0x6e, 0x61,
				0x77, 0x73, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00,
				0x01, 0x00, 0x01, 0x00, 0x00, 0x29, 0x02, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			},
			expected: 0x874e,
		},
		{
			name: "DNS standard query response",
			data: []byte{
				0xc0, 0xa8, 0x01, 0x01, 0xc0, 0xa8, 0x01, 0xc4,
				0x00, 0x11, 0x00, 0x44,
				0x00, 0x35, 0x9f, 0xe2, 0x00, 0x44, 0x73, 0xad,
				0x22, 0x97, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01,
				0x00, 0x00, 0x00, 0x01, 0x04, 0x64, 0x6f, 0x63,
				0x73, 0x06, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
				0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00,
				0x01, 0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
				0x00, 0x00, 0x78, 0x00, 0x04, 0xd8, 0x3a, 0xd4,
				0x4e, 0x00, 0x00, 0x29, 0x10, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
			},
			expected: 0x73ad,
		},
		{
			name: "DNS standard query response (odd length)",
			data: []byte{
				0xc0, 0xa8, 0x01, 0x01, 0xc0, 0xa8, 0x01, 0xc4,
				0x00, 0x11, 0x00, 0x44,
				0x00, 0x35, 0x9f, 0xe2, 0x00, 0x44, 0x73, 0xad,
				0x22, 0x97, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01,
				0x00, 0x00, 0x00, 0x01, 0x04, 0x64, 0x6f, 0x63,
				0x73, 0x06, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
				0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00,
				0x01, 0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
				0x00, 0x00, 0x78, 0x00, 0x04, 0xd8, 0x3a, 0xd4,
				0x4e, 0x00, 0x00, 0x29, 0x10, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00,
			},
			expected: 0x73ad,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Zero out the checksum field (bytes 18-19 in the pseudo+udp block)
			zeroed := make([]byte, len(tt.data))
			copy(zeroed, tt.data)
			binary.BigEndian.PutUint16(zeroed[18:20], 0)
			got := NetChecksum(zeroed)
			if got != tt.expected {
				t.Errorf("NetChecksum (zeroed) = 0x%04x, want 0x%04x", got, tt.expected)
			}

			// With correct checksum, result should be 0
			got = NetChecksum(tt.data)
			if got != 0 {
				t.Errorf("NetChecksum (intact) = 0x%04x, want 0x0000", got)
			}
		})
	}
}

func TestUnicastIPToMAC(t *testing.T) {
	arpContent := `IP address       HW type     Flags       HW address            Mask     Device
192.168.0.1      0x1         0x2         30:65:EC:6F:C4:58     *        eth0
192.168.0.2      0x1         0x2         30:65:ec:6f:c4:59     *        eth0`

	tests := []struct {
		ip       string
		expected string
	}{
		{"192.168.0.1", "30:65:EC:6F:C4:58"},
		{"192.168.0.2", "30:65:ec:6f:c4:59"},
		{"172.16.5.1", ""},
	}

	for _, tt := range tests {
		t.Run(tt.ip, func(t *testing.T) {
			got, err := UnicastIPToMAC(tt.ip, arpContent)
			if err != nil {
				t.Fatalf("unexpected error: %s", err)
			}
			if got != tt.expected {
				t.Errorf("UnicastIPToMAC(%s) = %q, want %q", tt.ip, got, tt.expected)
			}
		})
	}
}

func TestModifyUDPPacket(t *testing.T) {
	// DNS query packet
	dnsQuery := []byte{
		0x45, 0x00,
		0x00, 0x54, 0x33, 0x91, 0x40, 0x00, 0x40, 0x11, 0x84, 0x93, 0xc0, 0xa8, 0x00, 0x26,
		0xc0, 0xa8, 0x00, 0xfe, 0xdf, 0xdd, 0x00, 0x35, 0x00, 0x40, 0xfe, 0x24, 0x72, 0xb7,
		0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x09, 0x67, 0x6f, 0x6f,
		0x67, 0x6c, 0x65, 0x61, 0x64, 0x73, 0x01, 0x67, 0x0b, 0x64, 0x6f, 0x75, 0x62, 0x6c,
		0x65, 0x63, 0x6c, 0x69, 0x63, 0x6b, 0x03, 0x6e, 0x65, 0x74, 0x00, 0x00, 0x01, 0x00,
		0x01, 0x00, 0x00, 0x29, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	t.Run("no changes", func(t *testing.T) {
		result := ModifyUDPPacket(dnsQuery, 20, "", 0, "", 0)
		if len(result) != len(dnsQuery) {
			t.Fatalf("length mismatch: got %d, want %d", len(result), len(dnsQuery))
		}
		// The data portion should be identical
		for i := 20 + 8; i < len(result); i++ {
			if result[i] != dnsQuery[i] {
				t.Errorf("byte %d: got 0x%02x, want 0x%02x", i, result[i], dnsQuery[i])
			}
		}
	})

	t.Run("change IPs and ports", func(t *testing.T) {
		result := ModifyUDPPacket(dnsQuery, 20, "192.168.1.196", 57054, "91.189.91.157", 308)
		// Verify new source IP at bytes 12-15
		if result[12] != 0xc0 || result[13] != 0xa8 || result[14] != 0x01 || result[15] != 0xc4 {
			t.Errorf("source IP mismatch: got %v", result[12:16])
		}
		// Verify new dest IP at bytes 16-19
		if result[16] != 0x5b || result[17] != 0xbd || result[18] != 0x5b || result[19] != 0x9d {
			t.Errorf("dest IP mismatch: got %v", result[16:20])
		}
		// Verify new source port at bytes 20-21
		srcPort := binary.BigEndian.Uint16(result[20:22])
		if srcPort != 57054 {
			t.Errorf("source port = %d, want 57054", srcPort)
		}
		// Verify new dest port at bytes 22-23
		dstPort := binary.BigEndian.Uint16(result[22:24])
		if dstPort != 308 {
			t.Errorf("dest port = %d, want 308", dstPort)
		}
	})

	// SSDP multicast query
	ssdpQuery := []byte{
		0x45, 0x00,
		0x00, 0x99, 0x4a, 0x5f, 0x40, 0x00, 0x01, 0x11, 0x7c, 0xe2, 0xc0, 0xa8, 0x01, 0x70,
		0xef, 0xff, 0xff, 0xfa, 0xd9, 0x79, 0x07, 0x6c, 0x00, 0x85, 0x3e, 0x62, 0x4d, 0x2d,
		0x53, 0x45, 0x41, 0x52, 0x43, 0x48, 0x20, 0x2a, 0x20, 0x48, 0x54, 0x54, 0x50, 0x2f,
		0x31, 0x2e, 0x31, 0x0d, 0x0a, 0x48, 0x4f, 0x53, 0x54, 0x3a, 0x20, 0x32, 0x33, 0x39,
		0x2e, 0x32, 0x35, 0x35, 0x2e, 0x32, 0x35, 0x35, 0x2e, 0x32, 0x35, 0x30, 0x3a, 0x31,
		0x39, 0x30, 0x30, 0x0d, 0x0a, 0x4d, 0x41, 0x4e, 0x3a, 0x20, 0x22, 0x73, 0x73, 0x64,
		0x70, 0x3a, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x22, 0x0d, 0x0a, 0x4d,
		0x58, 0x3a, 0x20, 0x31, 0x0d, 0x0a, 0x53, 0x54, 0x3a, 0x20, 0x75, 0x72, 0x6e, 0x3a,
		0x64, 0x69, 0x61, 0x6c, 0x2d, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x73, 0x63, 0x72, 0x65,
		0x65, 0x6e, 0x2d, 0x6f, 0x72, 0x67, 0x3a, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
		0x3a, 0x64, 0x69, 0x61, 0x6c, 0x3a, 0x31, 0x0d, 0x0a, 0x0d, 0x0a,
	}

	t.Run("SSDP no changes", func(t *testing.T) {
		result := ModifyUDPPacket(ssdpQuery, 20, "", 0, "", 0)
		if len(result) != len(ssdpQuery) {
			t.Fatalf("length mismatch: got %d, want %d", len(result), len(ssdpQuery))
		}
		// Data after headers should match
		for i := 28; i < len(result); i++ {
			if result[i] != ssdpQuery[i] {
				t.Errorf("byte %d: got 0x%02x, want 0x%02x", i, result[i], ssdpQuery[i])
			}
		}
	})

	t.Run("SSDP change src only", func(t *testing.T) {
		result := ModifyUDPPacket(ssdpQuery, 20, "10.0.0.1", 1901, "", 0)
		// Check source IP is now 10.0.0.1
		if result[12] != 0x0a || result[13] != 0x00 || result[14] != 0x00 || result[15] != 0x01 {
			t.Errorf("source IP mismatch: got %v", result[12:16])
		}
		// Source port should be 1901 (0x076d)
		srcPort := binary.BigEndian.Uint16(result[20:22])
		if srcPort != 1901 {
			t.Errorf("source port = %d, want 1901", srcPort)
		}
	})
}

func TestIsMulticast(t *testing.T) {
	tests := []struct {
		ip       string
		expected bool
	}{
		{"224.0.0.0", true},
		{"239.255.255.255", true},
		{"224.0.0.251", true},
		{"239.255.255.250", true},
		{"192.168.1.1", false},
		{"255.255.255.255", false},
		{"10.0.0.1", false},
		{"not-an-ip", false},
		{"", false},
		{"999.999.999.999", false},
	}
	for _, tt := range tests {
		if got := IsMulticast(tt.ip); got != tt.expected {
			t.Errorf("IsMulticast(%s) = %v, want %v", tt.ip, got, tt.expected)
		}
	}
}

func TestIsBroadcast(t *testing.T) {
	if !IsBroadcast("255.255.255.255") {
		t.Error("255.255.255.255 should be broadcast")
	}
	if IsBroadcast("192.168.1.255") {
		t.Error("192.168.1.255 should not be global broadcast")
	}
}

func TestMulticastIPToMAC(t *testing.T) {
	t.Run("valid multicast IP", func(t *testing.T) {
		mac := MulticastIPToMAC("239.255.255.250")
		expected := []byte{0x01, 0x00, 0x5e, 0x7f, 0xff, 0xfa}
		for i := range expected {
			if mac[i] != expected[i] {
				t.Errorf("byte %d: got 0x%02x, want 0x%02x", i, mac[i], expected[i])
			}
		}
	})

	t.Run("invalid IP returns nil", func(t *testing.T) {
		if mac := MulticastIPToMAC("not-an-ip"); mac != nil {
			t.Errorf("expected nil for invalid IP, got %v", mac)
		}
	})

	t.Run("IPv6 address returns nil", func(t *testing.T) {
		if mac := MulticastIPToMAC("ff02::1"); mac != nil {
			t.Errorf("expected nil for IPv6 address, got %v", mac)
		}
	})

	t.Run("empty string returns nil", func(t *testing.T) {
		if mac := MulticastIPToMAC(""); mac != nil {
			t.Errorf("expected nil for empty string, got %v", mac)
		}
	})
}

func TestOnNetwork(t *testing.T) {
	tests := []struct {
		ip, network, netmask string
		expected             bool
	}{
		{"192.168.1.100", "192.168.1.0", "255.255.255.0", true},
		{"192.168.2.100", "192.168.1.0", "255.255.255.0", false},
		{"10.0.0.5", "10.0.0.0", "255.255.255.0", true},
		{"10.0.1.5", "10.0.0.0", "255.255.255.0", false},
		{"10.0.1.5", "10.0.0.0", "255.255.0.0", true},
	}
	for _, tt := range tests {
		got := OnNetwork(tt.ip, tt.network, tt.netmask)
		if got != tt.expected {
			t.Errorf("OnNetwork(%s, %s, %s) = %v, want %v", tt.ip, tt.network, tt.netmask, got, tt.expected)
		}
	}
}

func TestCIDRToNetmask(t *testing.T) {
	tests := []struct {
		bits     int
		expected string
	}{
		{24, "255.255.255.0"},
		{16, "255.255.0.0"},
		{8, "255.0.0.0"},
		{32, "255.255.255.255"},
		{20, "255.255.240.0"},
	}
	for _, tt := range tests {
		got := CIDRToNetmask(tt.bits)
		if got != tt.expected {
			t.Errorf("CIDRToNetmask(%d) = %s, want %s", tt.bits, got, tt.expected)
		}
	}
}

func TestIP2LongRoundTrip(t *testing.T) {
	ips := []string{"0.0.0.0", "192.168.1.1", "255.255.255.255", "10.0.0.1", "172.16.0.1"}
	for _, ip := range ips {
		got := Long2IP(IP2Long(ip))
		if got != ip {
			t.Errorf("round-trip failed for %s: got %s", ip, got)
		}
	}
}

func TestIP2LongInvalid(t *testing.T) {
	tests := []struct {
		name string
		ip   string
	}{
		{"empty string", ""},
		{"garbage", "not-an-ip"},
		{"IPv6", "::1"},
		{"out of range", "999.999.999.999"},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := IP2Long(tt.ip); got != 0 {
				t.Errorf("IP2Long(%q) = %d, want 0", tt.ip, got)
			}
		})
	}
}

func TestLong2IP(t *testing.T) {
	tests := []struct {
		input    uint32
		expected string
	}{
		{0x00000000, "0.0.0.0"},
		{0xc0a80101, "192.168.1.1"},
		{0xffffffff, "255.255.255.255"},
		{0x0a000001, "10.0.0.1"},
		{0xac100001, "172.16.0.1"},
		{0x7f000001, "127.0.0.1"},
	}
	for _, tt := range tests {
		t.Run(tt.expected, func(t *testing.T) {
			got := Long2IP(tt.input)
			if got != tt.expected {
				t.Errorf("Long2IP(0x%08x) = %s, want %s", tt.input, got, tt.expected)
			}
		})
	}
}

func TestBroadcastIPToMAC(t *testing.T) {
	mac := BroadcastIPToMAC()
	expected := net.HardwareAddr{0xff, 0xff, 0xff, 0xff, 0xff, 0xff}
	if !bytes.Equal(mac, expected) {
		t.Errorf("BroadcastIPToMAC() = %v, want %v", mac, expected)
	}
}

func TestComputeIPChecksum(t *testing.T) {
	// DNS query packet (full IP+UDP+payload)
	dnsQuery := []byte{
		0x45, 0x00, 0x00, 0x54, 0x33, 0x91, 0x40, 0x00, 0x40, 0x11, 0x84, 0x93,
		0xc0, 0xa8, 0x00, 0x26, 0xc0, 0xa8, 0x00, 0xfe,
		0xdf, 0xdd, 0x00, 0x35, 0x00, 0x40, 0xfe, 0x24,
		0x72, 0xb7, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01, 0x09, 0x67, 0x6f, 0x6f,
		0x67, 0x6c, 0x65, 0x61, 0x64, 0x73, 0x01, 0x67,
		0x0b, 0x64, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x63,
		0x6c, 0x69, 0x63, 0x6b, 0x03, 0x6e, 0x65, 0x74,
		0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x29,
		0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	t.Run("recompute from zeroed checksum", func(t *testing.T) {
		corrupted := make([]byte, len(dnsQuery))
		copy(corrupted, dnsQuery)
		corrupted[10] = 0x00
		corrupted[11] = 0x00

		result := ComputeIPChecksum(corrupted, 20)
		gotChecksum := binary.BigEndian.Uint16(result[10:12])
		if gotChecksum != 0x8493 {
			t.Errorf("ComputeIPChecksum checksum = 0x%04x, want 0x8493", gotChecksum)
		}
	})

	t.Run("recompute preserves correct checksum", func(t *testing.T) {
		result := ComputeIPChecksum(dnsQuery, 20)
		gotChecksum := binary.BigEndian.Uint16(result[10:12])
		if gotChecksum != 0x8493 {
			t.Errorf("ComputeIPChecksum checksum = 0x%04x, want 0x8493", gotChecksum)
		}
	})

	t.Run("modifies in place", func(t *testing.T) {
		input := make([]byte, len(dnsQuery))
		copy(input, dnsQuery)
		input[10] = 0
		input[11] = 0
		result := ComputeIPChecksum(input, 20)
		// result should be the same slice as input
		if &result[0] != &input[0] {
			t.Error("ComputeIPChecksum should return the same slice")
		}
		gotChecksum := binary.BigEndian.Uint16(input[10:12])
		if gotChecksum != 0x8493 {
			t.Errorf("in-place checksum = 0x%04x, want 0x8493", gotChecksum)
		}
	})

	t.Run("IGMPv2 multicast with options", func(t *testing.T) {
		// IP header with IHL=6 (24 bytes, has options)
		igmp := []byte{
			0x46, 0xc0, 0x00, 0x20, 0xe2, 0x92, 0x00, 0x00,
			0x01, 0x02, 0x9f, 0xda, 0xc0, 0xa8, 0x01, 0x01,
			0xe0, 0x00, 0x00, 0x01, 0x94, 0x04, 0x00, 0x00,
		}
		result := ComputeIPChecksum(igmp, 24)
		gotChecksum := binary.BigEndian.Uint16(result[10:12])
		if gotChecksum != 0x9fda {
			t.Errorf("ComputeIPChecksum checksum = 0x%04x, want 0x9fda", gotChecksum)
		}
	})
}

func TestComputeUDPChecksum(t *testing.T) {
	// DNS query packet
	dnsQuery := []byte{
		0x45, 0x00, 0x00, 0x54, 0x33, 0x91, 0x40, 0x00, 0x40, 0x11, 0x84, 0x93,
		0xc0, 0xa8, 0x00, 0x26, 0xc0, 0xa8, 0x00, 0xfe,
		0xdf, 0xdd, 0x00, 0x35, 0x00, 0x40, 0xfe, 0x24,
		0x72, 0xb7, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01, 0x09, 0x67, 0x6f, 0x6f,
		0x67, 0x6c, 0x65, 0x61, 0x64, 0x73, 0x01, 0x67,
		0x0b, 0x64, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x63,
		0x6c, 0x69, 0x63, 0x6b, 0x03, 0x6e, 0x65, 0x74,
		0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x29,
		0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	t.Run("DNS query", func(t *testing.T) {
		ipHeader := dnsQuery[:20]
		udpHeader := dnsQuery[20:28]
		data := dnsQuery[28:]

		result := ComputeUDPChecksum(ipHeader, udpHeader, data)
		if len(result) != 8 {
			t.Fatalf("result length = %d, want 8", len(result))
		}
		// Src port, dst port, and length should be preserved
		if !bytes.Equal(result[:6], udpHeader[:6]) {
			t.Errorf("first 6 bytes changed: got %v, want %v", result[:6], udpHeader[:6])
		}
		gotChecksum := binary.BigEndian.Uint16(result[6:8])
		if gotChecksum != 0xfe24 {
			t.Errorf("UDP checksum = 0x%04x, want 0xfe24", gotChecksum)
		}
	})

	// SSDP query packet
	ssdpQuery := []byte{
		0x45, 0x00, 0x00, 0x99, 0x4a, 0x5f, 0x40, 0x00, 0x01, 0x11, 0x7c, 0xe2,
		0xc0, 0xa8, 0x01, 0x70, 0xef, 0xff, 0xff, 0xfa,
		0xd9, 0x79, 0x07, 0x6c, 0x00, 0x85, 0x3e, 0x62,
		0x4d, 0x2d, 0x53, 0x45, 0x41, 0x52, 0x43, 0x48,
		0x20, 0x2a, 0x20, 0x48, 0x54, 0x54, 0x50, 0x2f,
		0x31, 0x2e, 0x31, 0x0d, 0x0a, 0x48, 0x4f, 0x53,
		0x54, 0x3a, 0x20, 0x32, 0x33, 0x39, 0x2e, 0x32,
		0x35, 0x35, 0x2e, 0x32, 0x35, 0x35, 0x2e, 0x32,
		0x35, 0x30, 0x3a, 0x31, 0x39, 0x30, 0x30, 0x0d,
		0x0a, 0x4d, 0x41, 0x4e, 0x3a, 0x20, 0x22, 0x73,
		0x73, 0x64, 0x70, 0x3a, 0x64, 0x69, 0x73, 0x63,
		0x6f, 0x76, 0x65, 0x72, 0x22, 0x0d, 0x0a, 0x4d,
		0x58, 0x3a, 0x20, 0x31, 0x0d, 0x0a, 0x53, 0x54,
		0x3a, 0x20, 0x75, 0x72, 0x6e, 0x3a, 0x64, 0x69,
		0x61, 0x6c, 0x2d, 0x6d, 0x75, 0x6c, 0x74, 0x69,
		0x73, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x2d, 0x6f,
		0x72, 0x67, 0x3a, 0x73, 0x65, 0x72, 0x76, 0x69,
		0x63, 0x65, 0x3a, 0x64, 0x69, 0x61, 0x6c, 0x3a,
		0x31, 0x0d, 0x0a, 0x0d, 0x0a,
	}

	t.Run("SSDP query", func(t *testing.T) {
		ipHeader := ssdpQuery[:20]
		udpHeader := ssdpQuery[20:28]
		data := ssdpQuery[28:]

		result := ComputeUDPChecksum(ipHeader, udpHeader, data)
		gotChecksum := binary.BigEndian.Uint16(result[6:8])
		if gotChecksum != 0x3e62 {
			t.Errorf("UDP checksum = 0x%04x, want 0x3e62", gotChecksum)
		}
	})
}

func TestOnNetworkPrefix(t *testing.T) {
	prefix := netip.MustParsePrefix("192.168.1.0/24")
	tests := []struct {
		name     string
		ip       string
		expected bool
	}{
		{"in range", "192.168.1.100", true},
		{"network address", "192.168.1.0", true},
		{"broadcast", "192.168.1.255", true},
		{"out of range", "192.168.2.1", false},
		{"invalid IP", "not-an-ip", false},
		{"empty string", "", false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := OnNetworkPrefix(tt.ip, prefix); got != tt.expected {
				t.Errorf("OnNetworkPrefix(%q, %s) = %v, want %v", tt.ip, prefix, got, tt.expected)
			}
		})
	}
}

func TestAddrFrom4Bytes(t *testing.T) {
	tests := []struct {
		name     string
		input    []byte
		expected string
	}{
		{"loopback", []byte{127, 0, 0, 1}, "127.0.0.1"},
		{"private", []byte{192, 168, 1, 1}, "192.168.1.1"},
		{"zeros", []byte{0, 0, 0, 0}, "0.0.0.0"},
		{"broadcast", []byte{255, 255, 255, 255}, "255.255.255.255"},
		{"class A", []byte{10, 0, 0, 1}, "10.0.0.1"},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			addr := AddrFrom4Bytes(tt.input)
			if got := addr.String(); got != tt.expected {
				t.Errorf("AddrFrom4Bytes(%v) = %s, want %s", tt.input, got, tt.expected)
			}
			if !addr.Is4() {
				t.Error("expected Is4() to be true")
			}
		})
	}
}

func TestMdnsSetUnicastBit(t *testing.T) {
	// Helper to build an mDNS packet with the given DNS payload
	buildPacket := func(dnsPayload []byte) []byte {
		ipHeader := []byte{
			0x45, 0x00, 0x00, 0x00, 0x12, 0x34, 0x00, 0x00,
			0x01, 0x11, 0x00, 0x00, 0xc0, 0xa8, 0x01, 0x64,
			0xe0, 0x00, 0x00, 0xfb,
		}
		udpLen := 8 + len(dnsPayload)
		udpHeader := []byte{
			0x14, 0xe9, 0x14, 0xe9,
			byte(udpLen >> 8), byte(udpLen), 0x00, 0x00,
		}
		totalLen := 20 + udpLen
		binary.BigEndian.PutUint16(ipHeader[2:4], uint16(totalLen))

		pkt := make([]byte, 0, totalLen)
		pkt = append(pkt, ipHeader...)
		pkt = append(pkt, udpHeader...)
		pkt = append(pkt, dnsPayload...)
		return pkt
	}

	t.Run("single query sets unicast bit", func(t *testing.T) {
		dns := []byte{
			0x00, 0x00, // Transaction ID
			0x00, 0x00, // Flags (standard query)
			0x00, 0x01, // Questions: 1
			0x00, 0x00, // Answer RRs
			0x00, 0x00, // Authority RRs
			0x00, 0x00, // Additional RRs
			// Query: _http._tcp.local
			0x05, '_', 'h', 't', 't', 'p',
			0x04, '_', 't', 'c', 'p',
			0x05, 'l', 'o', 'c', 'a', 'l',
			0x00,       // null terminator
			0x00, 0x0c, // Type: PTR
			0x00, 0x01, // Class: IN (no unicast bit)
		}
		pkt := buildPacket(dns)
		result := MdnsSetUnicastBit(pkt, 20)

		// The class field is at DNS offset 32-33 (after 12-byte header + 18-byte name + 2-byte type)
		// In the full packet: offset 20 (IP) + 8 (UDP) + 32 = 60
		classOffset := 20 + 8 + 12 + 18 + 2
		classField := binary.BigEndian.Uint16(result[classOffset : classOffset+2])
		if classField != 0x8001 {
			t.Errorf("class field = 0x%04x, want 0x8001", classField)
		}
	})

	t.Run("two queries both get unicast bit", func(t *testing.T) {
		dns := []byte{
			0x00, 0x00, // Transaction ID
			0x00, 0x00, // Flags
			0x00, 0x02, // Questions: 2
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			// Query 1: foo.local
			0x03, 'f', 'o', 'o',
			0x05, 'l', 'o', 'c', 'a', 'l',
			0x00,       // null
			0x00, 0x01, // Type: A
			0x00, 0x01, // Class: IN
			// Query 2: bar.local
			0x03, 'b', 'a', 'r',
			0x05, 'l', 'o', 'c', 'a', 'l',
			0x00,       // null
			0x00, 0x01, // Type: A
			0x00, 0x01, // Class: IN
		}
		pkt := buildPacket(dns)
		result := MdnsSetUnicastBit(pkt, 20)

		base := 20 + 8 // start of DNS payload
		// Query 1 class: offset 12 (header) + 11 (name) + 2 (type) = 25 from DNS start
		class1 := binary.BigEndian.Uint16(result[base+25 : base+27])
		if class1 != 0x8001 {
			t.Errorf("query 1 class = 0x%04x, want 0x8001", class1)
		}
		// Query 2 class: 25 + 4 (type+class of q1) + 1 padding? No...
		// Query 2 starts at DNS offset 27 (12 + 15 for q1)
		// Query 2 name: 11 bytes, type: 2 bytes, then class at offset 27+11+2 = 40
		class2 := binary.BigEndian.Uint16(result[base+40 : base+42])
		if class2 != 0x8001 {
			t.Errorf("query 2 class = 0x%04x, want 0x8001", class2)
		}
	})

	t.Run("response packet unchanged", func(t *testing.T) {
		dns := []byte{
			0x00, 0x00, // Transaction ID
			0x84, 0x00, // Flags: QR=1 (response), AA=1
			0x00, 0x01, // Questions: 1
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			// Query: foo.local
			0x03, 'f', 'o', 'o',
			0x05, 'l', 'o', 'c', 'a', 'l',
			0x00,
			0x00, 0x01, // Type: A
			0x00, 0x01, // Class: IN (without unicast bit)
		}
		pkt := buildPacket(dns)
		result := MdnsSetUnicastBit(pkt, 20)

		// Class should remain 0x0001 because QR bit is set
		base := 20 + 8
		classField := binary.BigEndian.Uint16(result[base+25 : base+27])
		if classField != 0x0001 {
			t.Errorf("class field = 0x%04x, want 0x0001 (unchanged for response)", classField)
		}
	})

	t.Run("already has unicast bit", func(t *testing.T) {
		dns := []byte{
			0x00, 0x00,
			0x00, 0x00, // Query flags
			0x00, 0x01,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x03, 'f', 'o', 'o',
			0x05, 'l', 'o', 'c', 'a', 'l',
			0x00,
			0x00, 0x01,
			0x80, 0x01, // Class: IN with unicast bit already set
		}
		pkt := buildPacket(dns)
		original := make([]byte, len(pkt))
		copy(original, pkt)

		result := MdnsSetUnicastBit(pkt, 20)

		// Should still be 0x8001
		base := 20 + 8
		classField := binary.BigEndian.Uint16(result[base+25 : base+27])
		if classField != 0x8001 {
			t.Errorf("class field = 0x%04x, want 0x8001", classField)
		}
	})
}
