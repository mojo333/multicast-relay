package relay

import (
	"encoding/binary"
	"testing"
)

func TestNetChecksumIPv4(t *testing.T) {
	tests := []struct {
		name     string
		header   []byte
		expected uint16
	}{
		{
			name: "IGMPv2 multicast to 224.0.0.1",
			header: []byte{
				0x46, 0xc0, 0x00, 0x20, 0xe2, 0x92, 0x00, 0x00,
				0x01, 0x02, 0x9f, 0xda, 0xc0, 0xa8, 0x01, 0x01,
				0xe0, 0x00, 0x00, 0x01, 0x94, 0x04, 0x00, 0x00,
			},
			expected: 0x9fda,
		},
		{
			name: "unicast tcp 216.58.198.174 -> 192.168.1.196",
			header: []byte{
				0x45, 0x00, 0x00, 0x34, 0xe0, 0xb3, 0x00, 0x00,
				0x79, 0x06, 0xff, 0xba, 0xd8, 0x3a, 0xc6, 0xae,
				0xc0, 0xa8, 0x01, 0xc4,
			},
			expected: 0xffba,
		},
		{
			name: "UDP DNS response",
			header: []byte{
				0x45, 0x00, 0x00, 0xb4, 0xf6, 0x22, 0x40, 0x00,
				0x40, 0x11, 0xc0, 0x00, 0xc0, 0xa8, 0x01, 0x01,
				0xc0, 0xa8, 0x01, 0xc4,
			},
			expected: 0xc000,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Zero out checksum and verify we compute the expected value
			zeroed := make([]byte, len(tt.header))
			copy(zeroed, tt.header)
			zeroed[10] = 0
			zeroed[11] = 0
			got := NetChecksum(zeroed)
			if got != tt.expected {
				t.Errorf("NetChecksum (zeroed) = 0x%04x, want 0x%04x", got, tt.expected)
			}

			// With the correct checksum in place, result should be 0
			got = NetChecksum(tt.header)
			if got != 0 {
				t.Errorf("NetChecksum (intact) = 0x%04x, want 0x0000", got)
			}
		})
	}
}

func TestNetChecksumUDP(t *testing.T) {
	tests := []struct {
		name     string
		data     []byte
		expected uint16
	}{
		{
			name: "NTP v4 client",
			data: []byte{
				// pseudo header: src_ip, dst_ip, 0, protocol, udp_length
				0xc0, 0xa8, 0x01, 0xc4, 0x5b, 0xbd, 0x5b, 0x9d,
				0x00, 0x11, 0x00, 0x38,
				// udp header + data
				0xd7, 0x6e, 0x00, 0x7b, 0x00, 0x38, 0x10, 0x1f,
				0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0xe0, 0x01, 0x7b, 0x46, 0x34, 0x2f, 0xeb, 0x36,
			},
			expected: 0x101f,
		},
		{
			name: "NTP v4 server",
			data: []byte{
				0x5b, 0xbd, 0x5b, 0x9d, 0xc0, 0xa8, 0x01, 0xc4,
				0x00, 0x11, 0x00, 0x38,
				0x00, 0x7b, 0xd5, 0x1e, 0x00, 0x38, 0x0d, 0x66,
				0x24, 0x02, 0x03, 0xe8, 0x00, 0x00, 0x08, 0x29,
				0x00, 0x00, 0x09, 0xab, 0x84, 0xf6, 0x0b, 0xe7,
				0xe0, 0x01, 0x76, 0xa5, 0x62, 0xb6, 0x0f, 0x58,
				0xe0, 0x01, 0x7c, 0x07, 0x16, 0x61, 0x28, 0xc4,
				0xe0, 0x01, 0x7c, 0x07, 0x53, 0xd6, 0x52, 0x7d,
				0xe0, 0x01, 0x7c, 0x07, 0x53, 0xda, 0xc1, 0xf6,
			},
			expected: 0x0d66,
		},
		{
			name: "DNS standard query",
			data: []byte{
				0xc0, 0xa8, 0x01, 0xc4, 0xc0, 0xa8, 0x01, 0x01,
				0x00, 0x11, 0x00, 0x4e,
				0xad, 0xa5, 0x00, 0x35, 0x00, 0x4e, 0x87, 0x4e,
				0xae, 0x06, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x01, 0x0d, 0x6e, 0x31, 0x2d,
				0x32, 0x31, 0x31, 0x36, 0x39, 0x37, 0x33, 0x36,
				0x34, 0x35, 0x09, 0x65, 0x75, 0x2d, 0x77, 0x65,
				0x73, 0x74, 0x2d, 0x31, 0x03, 0x65, 0x6c, 0x62,
				0x09, 0x61, 0x6d, 0x61, 0x7a, 0x6f, 0x6e, 0x61,
				0x77, 0x73, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00,
				0x01, 0x00, 0x01, 0x00, 0x00, 0x29, 0x02, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			},
			expected: 0x874e,
		},
		{
			name: "DNS standard query response",
			data: []byte{
				0xc0, 0xa8, 0x01, 0x01, 0xc0, 0xa8, 0x01, 0xc4,
				0x00, 0x11, 0x00, 0x44,
				0x00, 0x35, 0x9f, 0xe2, 0x00, 0x44, 0x73, 0xad,
				0x22, 0x97, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01,
				0x00, 0x00, 0x00, 0x01, 0x04, 0x64, 0x6f, 0x63,
				0x73, 0x06, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
				0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00,
				0x01, 0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
				0x00, 0x00, 0x78, 0x00, 0x04, 0xd8, 0x3a, 0xd4,
				0x4e, 0x00, 0x00, 0x29, 0x10, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
			},
			expected: 0x73ad,
		},
		{
			name: "DNS standard query response (odd length)",
			data: []byte{
				0xc0, 0xa8, 0x01, 0x01, 0xc0, 0xa8, 0x01, 0xc4,
				0x00, 0x11, 0x00, 0x44,
				0x00, 0x35, 0x9f, 0xe2, 0x00, 0x44, 0x73, 0xad,
				0x22, 0x97, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01,
				0x00, 0x00, 0x00, 0x01, 0x04, 0x64, 0x6f, 0x63,
				0x73, 0x06, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
				0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00,
				0x01, 0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
				0x00, 0x00, 0x78, 0x00, 0x04, 0xd8, 0x3a, 0xd4,
				0x4e, 0x00, 0x00, 0x29, 0x10, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00,
			},
			expected: 0x73ad,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Zero out the checksum field (bytes 18-19 in the pseudo+udp block)
			zeroed := make([]byte, len(tt.data))
			copy(zeroed, tt.data)
			binary.BigEndian.PutUint16(zeroed[18:20], 0)
			got := NetChecksum(zeroed)
			if got != tt.expected {
				t.Errorf("NetChecksum (zeroed) = 0x%04x, want 0x%04x", got, tt.expected)
			}

			// With correct checksum, result should be 0
			got = NetChecksum(tt.data)
			if got != 0 {
				t.Errorf("NetChecksum (intact) = 0x%04x, want 0x0000", got)
			}
		})
	}
}

func TestUnicastIPToMAC(t *testing.T) {
	arpContent := `IP address       HW type     Flags       HW address            Mask     Device
192.168.0.1      0x1         0x2         30:65:EC:6F:C4:58     *        eth0
192.168.0.2      0x1         0x2         30:65:ec:6f:c4:59     *        eth0`

	tests := []struct {
		ip       string
		expected string
	}{
		{"192.168.0.1", "30:65:EC:6F:C4:58"},
		{"192.168.0.2", "30:65:ec:6f:c4:59"},
		{"172.16.5.1", ""},
	}

	for _, tt := range tests {
		t.Run(tt.ip, func(t *testing.T) {
			got, err := UnicastIPToMAC(tt.ip, arpContent)
			if err != nil {
				t.Fatalf("unexpected error: %s", err)
			}
			if got != tt.expected {
				t.Errorf("UnicastIPToMAC(%s) = %q, want %q", tt.ip, got, tt.expected)
			}
		})
	}
}

func TestModifyUDPPacket(t *testing.T) {
	// DNS query packet
	dnsQuery := []byte{
		0x45, 0x00,
		0x00, 0x54, 0x33, 0x91, 0x40, 0x00, 0x40, 0x11, 0x84, 0x93, 0xc0, 0xa8, 0x00, 0x26,
		0xc0, 0xa8, 0x00, 0xfe, 0xdf, 0xdd, 0x00, 0x35, 0x00, 0x40, 0xfe, 0x24, 0x72, 0xb7,
		0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x09, 0x67, 0x6f, 0x6f,
		0x67, 0x6c, 0x65, 0x61, 0x64, 0x73, 0x01, 0x67, 0x0b, 0x64, 0x6f, 0x75, 0x62, 0x6c,
		0x65, 0x63, 0x6c, 0x69, 0x63, 0x6b, 0x03, 0x6e, 0x65, 0x74, 0x00, 0x00, 0x01, 0x00,
		0x01, 0x00, 0x00, 0x29, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	t.Run("no changes", func(t *testing.T) {
		result := ModifyUDPPacket(dnsQuery, 20, "", 0, "", 0)
		if len(result) != len(dnsQuery) {
			t.Fatalf("length mismatch: got %d, want %d", len(result), len(dnsQuery))
		}
		// The data portion should be identical
		for i := 20 + 8; i < len(result); i++ {
			if result[i] != dnsQuery[i] {
				t.Errorf("byte %d: got 0x%02x, want 0x%02x", i, result[i], dnsQuery[i])
			}
		}
	})

	t.Run("change IPs and ports", func(t *testing.T) {
		result := ModifyUDPPacket(dnsQuery, 20, "192.168.1.196", 57054, "91.189.91.157", 308)
		// Verify new source IP at bytes 12-15
		if result[12] != 0xc0 || result[13] != 0xa8 || result[14] != 0x01 || result[15] != 0xc4 {
			t.Errorf("source IP mismatch: got %v", result[12:16])
		}
		// Verify new dest IP at bytes 16-19
		if result[16] != 0x5b || result[17] != 0xbd || result[18] != 0x5b || result[19] != 0x9d {
			t.Errorf("dest IP mismatch: got %v", result[16:20])
		}
		// Verify new source port at bytes 20-21
		srcPort := binary.BigEndian.Uint16(result[20:22])
		if srcPort != 57054 {
			t.Errorf("source port = %d, want 57054", srcPort)
		}
		// Verify new dest port at bytes 22-23
		dstPort := binary.BigEndian.Uint16(result[22:24])
		if dstPort != 308 {
			t.Errorf("dest port = %d, want 308", dstPort)
		}
	})

	// SSDP multicast query
	ssdpQuery := []byte{
		0x45, 0x00,
		0x00, 0x99, 0x4a, 0x5f, 0x40, 0x00, 0x01, 0x11, 0x7c, 0xe2, 0xc0, 0xa8, 0x01, 0x70,
		0xef, 0xff, 0xff, 0xfa, 0xd9, 0x79, 0x07, 0x6c, 0x00, 0x85, 0x3e, 0x62, 0x4d, 0x2d,
		0x53, 0x45, 0x41, 0x52, 0x43, 0x48, 0x20, 0x2a, 0x20, 0x48, 0x54, 0x54, 0x50, 0x2f,
		0x31, 0x2e, 0x31, 0x0d, 0x0a, 0x48, 0x4f, 0x53, 0x54, 0x3a, 0x20, 0x32, 0x33, 0x39,
		0x2e, 0x32, 0x35, 0x35, 0x2e, 0x32, 0x35, 0x35, 0x2e, 0x32, 0x35, 0x30, 0x3a, 0x31,
		0x39, 0x30, 0x30, 0x0d, 0x0a, 0x4d, 0x41, 0x4e, 0x3a, 0x20, 0x22, 0x73, 0x73, 0x64,
		0x70, 0x3a, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x22, 0x0d, 0x0a, 0x4d,
		0x58, 0x3a, 0x20, 0x31, 0x0d, 0x0a, 0x53, 0x54, 0x3a, 0x20, 0x75, 0x72, 0x6e, 0x3a,
		0x64, 0x69, 0x61, 0x6c, 0x2d, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x73, 0x63, 0x72, 0x65,
		0x65, 0x6e, 0x2d, 0x6f, 0x72, 0x67, 0x3a, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
		0x3a, 0x64, 0x69, 0x61, 0x6c, 0x3a, 0x31, 0x0d, 0x0a, 0x0d, 0x0a,
	}

	t.Run("SSDP no changes", func(t *testing.T) {
		result := ModifyUDPPacket(ssdpQuery, 20, "", 0, "", 0)
		if len(result) != len(ssdpQuery) {
			t.Fatalf("length mismatch: got %d, want %d", len(result), len(ssdpQuery))
		}
		// Data after headers should match
		for i := 28; i < len(result); i++ {
			if result[i] != ssdpQuery[i] {
				t.Errorf("byte %d: got 0x%02x, want 0x%02x", i, result[i], ssdpQuery[i])
			}
		}
	})

	t.Run("SSDP change src only", func(t *testing.T) {
		result := ModifyUDPPacket(ssdpQuery, 20, "10.0.0.1", 1901, "", 0)
		// Check source IP is now 10.0.0.1
		if result[12] != 0x0a || result[13] != 0x00 || result[14] != 0x00 || result[15] != 0x01 {
			t.Errorf("source IP mismatch: got %v", result[12:16])
		}
		// Source port should be 1901 (0x076d)
		srcPort := binary.BigEndian.Uint16(result[20:22])
		if srcPort != 1901 {
			t.Errorf("source port = %d, want 1901", srcPort)
		}
	})
}

func TestIsMulticast(t *testing.T) {
	tests := []struct {
		ip       string
		expected bool
	}{
		{"224.0.0.0", true},
		{"239.255.255.255", true},
		{"224.0.0.251", true},
		{"239.255.255.250", true},
		{"192.168.1.1", false},
		{"255.255.255.255", false},
		{"10.0.0.1", false},
	}
	for _, tt := range tests {
		if got := IsMulticast(tt.ip); got != tt.expected {
			t.Errorf("IsMulticast(%s) = %v, want %v", tt.ip, got, tt.expected)
		}
	}
}

func TestIsBroadcast(t *testing.T) {
	if !IsBroadcast("255.255.255.255") {
		t.Error("255.255.255.255 should be broadcast")
	}
	if IsBroadcast("192.168.1.255") {
		t.Error("192.168.1.255 should not be global broadcast")
	}
}

func TestMulticastIPToMAC(t *testing.T) {
	mac := MulticastIPToMAC("239.255.255.250")
	expected := []byte{0x01, 0x00, 0x5e, 0x7f, 0xff, 0xfa}
	for i := range expected {
		if mac[i] != expected[i] {
			t.Errorf("byte %d: got 0x%02x, want 0x%02x", i, mac[i], expected[i])
		}
	}
}

func TestOnNetwork(t *testing.T) {
	tests := []struct {
		ip, network, netmask string
		expected             bool
	}{
		{"192.168.1.100", "192.168.1.0", "255.255.255.0", true},
		{"192.168.2.100", "192.168.1.0", "255.255.255.0", false},
		{"10.0.0.5", "10.0.0.0", "255.255.255.0", true},
		{"10.0.1.5", "10.0.0.0", "255.255.255.0", false},
		{"10.0.1.5", "10.0.0.0", "255.255.0.0", true},
	}
	for _, tt := range tests {
		got := OnNetwork(tt.ip, tt.network, tt.netmask)
		if got != tt.expected {
			t.Errorf("OnNetwork(%s, %s, %s) = %v, want %v", tt.ip, tt.network, tt.netmask, got, tt.expected)
		}
	}
}

func TestCIDRToNetmask(t *testing.T) {
	tests := []struct {
		bits     int
		expected string
	}{
		{24, "255.255.255.0"},
		{16, "255.255.0.0"},
		{8, "255.0.0.0"},
		{32, "255.255.255.255"},
		{20, "255.255.240.0"},
	}
	for _, tt := range tests {
		got := CIDRToNetmask(tt.bits)
		if got != tt.expected {
			t.Errorf("CIDRToNetmask(%d) = %s, want %s", tt.bits, got, tt.expected)
		}
	}
}

func TestIP2LongRoundTrip(t *testing.T) {
	ips := []string{"0.0.0.0", "192.168.1.1", "255.255.255.255", "10.0.0.1", "172.16.0.1"}
	for _, ip := range ips {
		got := Long2IP(IP2Long(ip))
		if got != ip {
			t.Errorf("round-trip failed for %s: got %s", ip, got)
		}
	}
}
